1. TCP/IP网络模型：应用层，传输层（TCP，UDP），网络层（IP），数据链路层，物理层

2. HTTP（超文本传输协议）：计算机世界里专门在两点之间传输超文本数据的约定和规范。常见状态码：1xx:提示信息，2xx:成功， 3xx:重定向，4xx:用户发送报文有误，5xx:服务器错误。

3. GET：请求从服务器获取资源。  POST：向URI指定的资源提交数据（数据放在报文里）。

4. 安全：请求方法不会破坏服务器上的资源。 幂等：多次执行效果都是相同的。 GET是安全和幂等的，POST既不是安全也不是幂等的。

5. HTTP1.1: 
   1. 优点：简单灵活，易于拓展(协议中方法没有被定义死，允许开发者自定义)，（报文=header（key,value）+body）
   2. 缺点：无状态（解决方案：Cookie（通过在响应报文中写入Cookie来控制客户端的状态）），明文传输（方便调试但信息裸奔），不安全。  HTTPS（端口443）（混合加密，摘要算法，数字证书）：在HTTP（端口80）与TCP之间增加安全传输层，使得报文能加密传输，增加传输的安全性，建立TCP连接后还有加密解密的连接。
   3. 性能：基于TCP/IP，使用请求应答通信模型。是长连接的（HTTP1.0是短连接（每次发送一个请求都要重新进行一次TCP连接））
   
6. HTTP2：基于HTTPS。改进：1.压缩头部  2.使用二进制格式（增加数据传输效率） 3.服务器推送（不单纯是请求应答模式，服务器可以主动发消息） 4.

7. HTTP3：改进HTTP可能会发生的丢包问题，下层采用UDP+QUIC协议

8. HTTP1.1优化：
   1. 使用keepAlive改为长连接
   2. 避免发送HTTP请求：缓存在本地，减少重定向请求次数（代理服务器），合并请求，延迟发送请求
   3. 减少HTPP响应数据的大小：数据压缩
   
9. TCP：TCP是面向连接的，可靠的，基于字节流的传输层协议。（首部20+x byte,UDP首部：8byte）。用于保证可靠性和流量控制维护某些信息，包括，Scoket，序列号，窗口大小。
   1. 为什么是3次握手：避免重复历史连接（先发出的请求后到），同步双方初始序列号。
   2. SYN攻击：不断向服务器发送SYN，而服务器发出的ACK没法得到响应。导致服务端的SYN队列满
   3. 四次挥手：C:我想关了，不发数据。S:好的，我知道了，但是等等我还有数据没发。 S:我发完了，你可以关了 C:好的
   4. 重传机制：累计确认应答（滑动窗口（流量控制）：接收方告诉发送方自己窗口大小，发送方按照这个标准发数据），超时重传。
   5. 拥塞控制：避免发送方发送过多数据到网络中，拥塞窗口（cwnd）由发送方自己维护。只要网络没有发送拥塞cwnd增大，否则减小。（怎么知道拥塞：ACK没有及时到达。）
      1. 慢启动：慢慢增加可发送的数据量：指数增长（到慢启动门限）
      2. 拥塞避免：线性增长
      3. 拥塞发生：超时重传：慢启动    快速重传：快恢复
   
10. IP ，DNS ，ARP （IP->MAC），DCHP(用udp广播(DCHP 中继代理（解决不同局域网问题）):discover ,offer,request,ack)，NAT （网络地址转换），ICMP（确认IP包是否成功到达，ping基于ICMP）。

11. 键入网址到显示网页放生了什么：
    1. URL解析，DNS（hosts,本地，根。。。）查找IP，
    2. 产生HTTP请求（协议栈（TCP，IP，UDP））（打包好了）
    3. 网卡：数字信号转化为电信号
    4. 送别：交换机，路由器
    5. 到达服务器：服务器拆包裹，知道对方要什么
    6. 完成：服务器把数据发了过来
    
12.  FTP
     1.  （C/S）模型
     2.  FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接，一条是数据连接，用于数据传送；另一条是控制连接，用于传送控制信息（命令和响应）
     3.  FTP的传输有两种方式：ASCII、二进制
     4.  FTP支持两种模式：Standard （PORT方式，主动方式），Passive （PASV，被动方式）。
     
13.  TCP三次握手四次挥手

     1.  为什么是三次不是两次？

         ```markdown
         1. 为什么要握手？
         答：因为TCP是一个可靠的数据传输协议（用seq+ack的机制来保证可靠传输），而且TCP是一个全双工的协议，客户端和服务端都必须要维护并同步彼此的seq.
         2. 为什么是三次握手？
         答：为了实现可靠传输，通信双方都必须维护一个序列号以标识已经发出去的数据中那些已经被收到。如果是两次握手，发送方序号能同步，但接收方序号得不到同步（因为没收到确认信号）。
         //《计算机网络》中的回答：防止已经失效的连接又传回服务端，因而产生错误。（不记这个啦，服务端接到请求就建立连接，可能空等，浪费资源。）
         换个角度理解为什么是三次握手：想要实现全双工通信，必须保证双方的发送，接收功能都是完好的。想要得到这个保证，必须经历三次握手（可以自己慢慢推导）
         3. 为什么不是四次握手？
         答：三次就够了，为什么要四次？
         ```

     2.  为什么是四次挥手？

         ```markdown
         1. 为什么是四次握手呢？
         答：TCP是一个全双工的协议，当有任何一方想要断开连接必须通知对方，且等待对方做好剩余的工作。
         2. 为什么客户端收到接收端的FIN报文后还要等待2MSL的时间？
         答：确保A发出去的最后一个报文能够顺利到达B，如果超时B会再向A发送一个报文；而且该缓冲时间也可以让本次连接的所有报文在网络中消失，避免对下一次连接造成影响。
         ```

14. TCP粘包和拆包

    1. 为什么说TCP有该问题，UDP为什么没有？

       ```markdown
       答：UDP是基于报文传输的，首部有对报文数据长度的标识，不会造成该问题。TCP是面向字节流的，s把数据分割成大小不同的数据包，所以会造成粘包和拆包问题。
       ```

    2. 为什么会发送粘包和拆包问题？

       ```markdown
       答：要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。
       待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。
       要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。
       接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。
       ```

    3. 怎么解决粘包和拆包问题？

       ```markdown
       由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：
       1. 消息定长：发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
       2. 设置消息边界：服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。
       3. 将消息分为消息头和消息体：消息头中包含表示消息总长度（或者消息体长度）的字段。
       ```

15. 
