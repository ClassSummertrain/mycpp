1. Linux将头文件位置加入环境变量：在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数

   ```shell
   #修改 /etc/profile文件 （全局的，每个用户都可见）
   #source /etc/profie 可以让修改立即生效
   #echo $PATH 显示环境变量
   ```

2. 添加删除多行注释方法

   ```shell
   # 1.按esc进入命令行模式
   # 2.Ctrl+V进入列模式
   # 3.上下键旋转插入注释的行
   # 4.I插入(d,x删除)，然后退出
   ```

3. core file(core文件其实就是内存的映像，当程序崩溃时，存储内存的相应信息，主用用于对程序进行调试)

   ```shell
   # ulimit -c //0则表示生成core file的功能没有打开
   # ulimit -c 1024 //表示生成大小最多未1024的core文件（临时）
   # 别看了，不懂不懂！！！！
   ```

4. linux多进程

   ```cpp
   //fork函数
   //1.一个现有的进程调用fork()函数创建一个新的进程
   //2.子进程和父进程继续执行fork()函数后的代码
   //3.fork()函数调用一次，返回两次。子进程返回0，父进程返回子进程的进程ID
   //4.子进程获得了父进程的数据空间，堆栈的副本。不是共享！！！
   //5.fork()失败返回-1
   //6.如果父进程先退出，子进程会变成孤儿进程
   //7.如果子进程先退出，内核向父进程发送SIGCHLD信号，不处理该信号子进程将会成为僵尸进程。
   ```

5. wait函数

   ```cpp
   /*进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成
   僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。
   参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉的毫不在意，
   只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，就象下面这样：*/
   pid = wait(NULL);
   
   ```


6. 进程与线程

   ```markdown
   1. 进程与线程：
   	进程拥有PCB，有独立的地址空间
   	进程是轻量级得进程，本质仍是进程
   	线程拥有PCB，但是没有独立的地址空间
   	线程是CPU最小的执行和调度的单位
   	进程是最小的资源分配单位，（同一进程内）多个线程共享进程的资源
   	从程序员的角度看：进程与线程的区别是是否共享地址空间
   	
   2. 线程优缺点：
   	可以实现进程内并发
   	开销少，创建线程比创建进程快
   	数据通信，数据共享方便，同时也增加了开发难度
   	
   3. 线程非正常中止
   	如果主线程退出，全部线程将强行终止
   	在子线程调用exit()将中止整个进程
   	缺省行为为中止程序的信号发送给某个线程将会中止整个程序
   	
   4. 线程中止方法
   	线程可以从线程函数中返回，返回值是线程的退出码(return 0(其他数值要强制转换))
   	线程可以被同一进程中的其他线程调用pthread_cancel()取消
   	在线程函数中，调用pthread_exit()退出。(与1的区别就像exit与return的区别)
   	
   5. 线程参数的传递 （各种强制转换，人傻了呀）
   
   6. 线程的资源回收
   	非分离的线程，退出后由主线程jion，释放资源
   	分离的线程，退出后系统自动回收资源，不需要jion （用pthread_detach(pthread_slef())）
   	线程清理函数,pthread_clean_.. push和pop在同一语句块中要成对出现。线程中止或语句块结束，线程清理函数将被执行。
   	线程取消，延迟取消（运行到下一个取消点取消），立即取消
   7. 线程和信号
   	多线程程序中，外部信号不会中断系统调用。（多进程会）
   	多线程信号处理是共享的
   	进程中的信号会中断系统调用
   	某线程因为信号中止，整个进程玩完儿
   8. 线程安全
   	原子性：一个操作（有可能包含多个子操作）要么全部执行，要么都不执行。（i++不是原子操作）
   	可见性：多个线程并发访问共享变量时，一个线程对共享变量的修改，其他线程应该能够立即看到（CPU高速缓存导致可能不可见）
   	顺序性：程序执行的顺序按照代码先后顺序。（CPU不保证完全按代码执行，但是其保证最终执行结果和按代码顺序执行结果一样。（即对代码做了优化））。
   	volatile：保证变量的内存可见性，禁止代码重排序。但不是原子的。
   	原子操作：本质是硬件级别的锁（效率高，但是只支持数值类型）
   9. 线程同步
   	互斥锁：这个简单。。。
   	自旋锁：等待时不断检查，不休眠（适用于等待时间短的场景）
   	读写锁：这个也简单。。。（Linux是读锁优先，可能会导致写锁饿死）
   	信号量：这个也还好。。。
   10. 生产者消费者：这个也还好。。
   ```

7. 网络相关linux命令

   ```markdown
   1. ping:通常用于对网络可用性的检查。
   2. netstat:可以显示路由表，实际网络连接及没有网络设备的信息。常用于检验本机各个端口的网络连接情况
   3. lsof:可以查看进程打开的文件，端口等。
   4. ifconfig:用于配置和查看网络接口设备参数。
   5. tcpdump:z
   ```
   
   
   
   
