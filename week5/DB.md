# DB

## 事务

```markdown
事务特性：事务（Transaction）是由一条或多条操作数据库的 SQL 语句组成的一个不可分割的工作单元，这些操作要么都完成，要么都取消。数据库必须满足以下四个特性
1. 原子性（Atomic）：将事务所进行的操作捆绑成一个不可分割的单元，即事务对数据库做的操作要么全部执行，要么不执行。
2. 一致性（Consistency）：表示事务完成后数据都保持一致的状态。
3. 隔离性（Isolation）：一个事务的执行不能被其他事务干扰。并发执行的事务不能相互干扰。
4. 持久性（Durability）：指一个事务一旦提交，他对数据据的改变应该是永久的。提交后的其他操作不会对其有任何影响。

并发事务引发的问题：
1. 脏读：一个事务读取到另一个事务还未提交的数据（a）
2. 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同。(b)
3. 幻读：一个事务按照条件查询数据时，没有对应行，但插入数据时，又发现数据已经存在，好像出现了一个幻影。(c)

事务隔离级别：[可能出现的问题]
1. 读未提交：[a,b,c]
2. 读已提交：[b,c]
3. 可重复读：[c]
4. 串行化：[]

```

## 约束

```markdown
1. 概念：约束是作用于**表中字段**上的规则，用于限制存储在表中的数据。目的是保证数据库中数据的正确性，有效性和完整性。
2. 分类：非空约束,唯一约束，主键约束（非空且唯一），默认约束，检查约束，外键约束（用来让两张表数据之间建立连接）
```

## 多表查询

```markdown
1. 多表关系：
	一对多：【案例：部门与员工】，【实现：在多的一方建立外键指向一的一方的主键】
	多对多：【案例：学生与课程】，【实现：建立中间表，至少包含两个外键，分别关联两方主键】
	一对一：【案例：用户与用户关系】，常用于做单表的拆分【实现：在任意一方加入外键（unique）关联另一方主键】
	
2. 多表查询：进行多表查询时需要消除无效的笛卡尔积
	连接查询：内连接，外连接，子链接（必须使用别名）
	联合查询：把多次查询结果合并起来，形成新的查询结果集。
	子查询：
```

## 存储引擎

```markdown
MySQL体系结构：连接层，服务层，引擎层，存储层
概念：存储引擎是存储数据，建立索引，更新/查询数据等技术的实现方式。存储引擎是基于表的，也叫表的类型。

InnoDB:兼顾高可靠性和高性能的通用存储引擎。
	特点：支持事务，支持外键，行级锁
	逻辑存储结构：表空间，段，区(1M)，页(16K,磁盘操作最小单元)，行
MyISAM:MySQL早期的默认引擎（被MongoDB取代）
	特点：不支持事务，不支持外键，支持表锁，不支持行级锁，访问速度快
Memory（被Redis取代）：表数据存放在内存中，由于硬件限制，或断电限制，只能将这些表作为临时表或缓存使用。
	特点：内存存放，支持hash索引
```

## 索引

```markdown
1. 索引是高效获取数据的数据结构。
2. 索引结构：
	B+Tree：最常用
	Hash：只能精确匹配不支持范围查询。
	R-Tree：主要用于地理空间数据类型，使用较少
	Full-Text：通过建立倒排索引，快速匹配文档。
	为什么用B+Tree？
答：
	1.AVL在顺序插入时会形成一个链表，性能大大降低，大数据情况下层级较深，检索速度慢，且AVL维护索引代价大；
	2.RBTree虽不会形成链表，但是本质还是二叉树，大数据下，层级深。
	3.BTree（中间元素向上裂变）
	4.B+Tree，所有元素出现在叶子节点，叶子节点形成一个链表。（MySQL中是双向循环链表）
	MySQL：每个节点存放在一个页（16K）中。对于B树来说无论是叶子节点还是非叶子节点都会保存数据。这样导致每页中存储的键值减少，指针跟着减少。要同样保存大量数据，只能增加树的高度，性能降低。数据都在叶子节点，搜索效率稳定。所有数据形成链表便于范围查询。hash只支持精确查找，无序，不支持范围查找。所以用B+Tree。
	
3. 索引分类
	1.主键索引：默认自动创建，只有一个 	PRIMARY
	2.唯一索引：避免某一列中值重复  UNIQUE
	3.常规索引：
	4.全文索引：查找文本中的关键字而不是比较索引值  FULLTEXT
	
	1.聚集索引：将数据与索引存放在一起，索引结构的叶子节点保存了行数据 有且只有一个 选取规则（primary->unique->自动生成一个）
	2.二级索引：将数据与索引分来存放，索引结构的叶子节点关联的是对应的主键
	
4. SQL性能分析：
	1. 查看SQL语句执行频次
	2. 慢查询日志：记录执行实现超过预设参数的所有SQL语句。
	3. profile详情：查看每条query语句执行耗时，查看每条query语句每个阶段的耗时，甚至是CPU耗用情况
	4. explain执行计划：查看语句执行顺序
	
5. 索引使用原则：
	1. 最左前缀法则：（联合索引）查询从索引的最左列开始，并且不跳过索引中的列。如果跳过某一列，后续的索引将部分失效
	2. 范围查询:范围查询右侧列失效
	3. 不要在索引列进行运算
	4. 不要让索引发生隐式类型转换（比如忘记字符串写引号）
	5. 尾部模糊匹配索引不失效，尾部模糊匹配索引失效。
	6. 数据分布影响
	7. SQL提示（告诉MySQL用哪一个索引）
	8. 覆盖索引：减少select \*
	9. 前缀索引：只使用字符串的前几个字符做索引，节约索引空间。
	10. 单列索引 vs 联合索引
	
6. 索引设计原则：。。。	
```

## SQL优化

```markdown
1. 插入优化
	1. 批量插入（减少多次插入造成与MySQL的频繁连接断开）
	2. 手动提交事务（将多条插入语句合并为一个事务提交，避免事务的频繁自动开闭与关闭）
	3. 主键顺序插入
	4. 大批量数据插入时启用load命令
2. 主键优化
	1. InnoDB
	2. 主键乱序插入会造成页分裂现象
	3. 页合并现象阈值默认为50%
	4. 主键设计原则：【满足业务要求下，尽量降低主键长度】【插入时尽量顺序插入】【尽量不用UUID主键或其他自然主键（如身份证号）】【避免对主键的修改】
3. order by优化：
	1. 根据排序字段建立合适索引，多字段时也遵循最左前缀法则
	2. 尽量使用覆盖索引
	3. 注意降序/升序规则
4. group by优化：
	1. 在进行分组时建立适当索引来提高效率
	2. 分组操作时，索引的使用也要满足最左前缀法则
5. limit优化:
	1. 覆盖索引+子查询
6. count优化：自己维护计数（没啥好的优化策略）
7. update优化：更新数据时对索引字段更新（即尽量不要添加表锁）
```

## 视图&存储过程&触发器

```markdown
1. 视图VIEW：视图是一张虚拟存在的表，其只保存基表的逻辑，数据是动态生成的。
	1. 视图检查选项，（cascaded(默认),local）
	2. 视图必须和基表中行是一对一的关系才能更新，否则不能更新（比如用了一些聚合函数）
	3. 视图的作用：简单（可以将常用的查询定义为视图，从而使用户简化操作），安全（数据库可以授权，但不能授权到具体的行和列，通过视图用户只能查询，修改他们所能看到的数据），数据独立（视图可以帮助用户屏蔽真实表结构变化带来的影响）
	
2. 存储过程PROCEDURE：事先经过编译并存储在数据库中的一段SQL语句集合，调用存储过程可以简化开发的工作，减少数据在数据库和服务器之间的传输。【特点：封装复用，可以接收参数也可以返回数据，减少网络交换，效率提升】 （和自定义函数很像啊）
	1.变量【系统变量，是MySQL提供的，属于服务器层面。分为GLOBAL,SESSION】【用户自定义变量，不用声明 使用"@变量名"】【局部变量，需要DECLARE声明】
	2.【条件语句if】【参数 in out inout】【流程控制case,while,reapt,loop】
	3. 游标CURSOR：用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括声明，打开，h和关闭。
	4. 条件处理程序handler
3. 存储函数FUNCTION：有返回值的函数类型，所有参数都是in
4. 触发器TRIGGER：触发器是与表有关的数据库对象，指在insert/delete/update之前或之后触发并执行触发器中定义的SQL语句集合。可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等工作。
```

## 锁

```markdown
1. 锁MUTEX:
	1. 全局锁：对整个数据库实例加锁（典型常见：对全库进行数据备份）
	2. 表级锁：锁粒度大，冲突概率大，并发低【表锁：读锁，写锁】【元数据锁：系统自动控制规避DML和DDL冲突，保证读写的正确性】【意向锁：避免表锁与行锁的冲突，意向共享锁IS，意向排它锁IX】
	3. 行级锁：锁粒度小，冲突概率小，并发高，（主要争对索引加锁）【行锁，I，S】【间隙锁】【临建锁】
```

## InnoDB引擎

```markdown
1. InnoDB逻辑存储结构：
	1. 表空间：用于存储记录，索引等数据
	2. 段：分为数据段（叶子节点）和索引段（非叶子节点）
	3. 区（1M）：表空间的单元结构，一个区中有64个页
	4. 页（16K）：磁盘管理最小单位，为了保证页的连续性，每次从磁盘申请4-5个区
	5. 行：InnoDB存储的数据按行存放
2. 架构:
	1. 内存结构：
		1. Buffer Pool:先操作缓冲区，然后在一定条件下刷新到磁盘，从而减少磁盘IO，加快处理速度。（缓冲池以页为单位，底层采用链表管理page,[free page,clean page,dirty page]）
		2. Change Buffer:针对非唯一的二级索引。在执行DML语句时，如果这些数据page不在buffer pool中，不会直接操作磁盘，而会将数据变更存放在Change Buffer中，在未来数据被读取时，再将数据合并到Buffer Pool中，再将合并后的数据刷新到磁盘中。【作用：待考究】
		3. Adaptive Hash Index：用于优化对Buffer Pool中的数据查询，无须人工干预，系统自动完成。
		4. Log Buffer:用来保存要写入磁盘的log日志，如有过多删除，更新，插入的事务，增加该区域大小会减少磁盘IO。[redo log],[undo log]
	2. 磁盘结构：
		1. System Tablespace:Change Buffer的存储区域
		2. File-Pre-Table Tablespace:每个表的文件表空间包含单个InnoDB表的数据和索引
		3. General Tablespace:通用表空间（知道就行）
		4. Undo Tablespace:存储undo log日志
		5. Tempororay Tablespace:InnoDB使用会话临时创建的空间，用于存储用户创建的临时表等数据
		6. Doublewrite Buffer Files:引擎先将数据页从Buffer Pool刷新到磁盘前，先将数据写入到双写缓冲区文件中，便于系统异常时恢复数据。
		7. Redo Log:用来实现事务的持久性。事务提交之后会把所有修改信息保存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复。以循环方式写入。
	3. 后台线程：负责将内存中的缓冲数据刷新到磁盘
		1. Master Thread
		2. IO Thread
		3. Purge Thread
		4. Page Cleaner Thread
3. 事务原理
	1. redo log:用来实现事务的持久性。事务提交之后会把所有修改信息保存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复。以循环方式写入。(事务提交时会将记录的数据页变化刷新到磁盘中永久性保存，如果之后脏页刷新时出错，可以通过redo log来恢复。)（不使用redo log会造成大量随机磁盘IO，使用redo log是顺序磁盘IO）(每隔一段时间会去清理redo log日志)
	2. undo log:保证原子性。回滚日志，用于记录数据被修改前的信息。【作用：提供回滚和MVCC】。【与redo log不同的是undo log记录的是逻辑日志。】【销毁：事务提交时不会立即销毁，可能还会用于MVCC】【存储：存放在段中】
4. MVCC：维护一个数据的多个版本，使得读写操作没有冲突。快照读为MySQL实现了一个非阻塞的方法。
	1. 当前读：读取的记录是最新版本，读取时保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。
	2. 快照读：读取到的可能是历史数据，不加锁，非阻塞。
	3. MVCC实现原理：
		1. 【记录的隐藏字段，（最近修改记录的事务id，回滚指针指向记录的上一个版本，隐藏主键）】
	  	2. 【undo log版本链:不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一个版本记录链】
	  	3. 【ReadView:快照读SQL执行时MVCC提取数据的依据（比较当前事务id和之前ReadView的属性值），记录并维护当前活跃（未提交）的事务id】
		
```

## MySQL管理

```markdown
1. 系统数据库（）不同版本不同
	1. mysql:MySQL运行时所需要的各种信息
	2. information_schema:提供访问数据库元数据据的各种表和视图
	3. performance_schema:为MySQL服务器运行状态提供一个底层监控功能
	4. sys:...
2. 常用工具：
	1. [mysql],[mysqladmin],[mysqlbinlog],[mysqlshow],[mysqldump],[mysqlimport/]
```


