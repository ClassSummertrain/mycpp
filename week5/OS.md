## 浅学

1. 进程运行状态： ps -aux | grep PID
2. 查看内存情况：free
3. 文件权限： chmod owner/group/other
4. 软链接vs硬链接 （硬链接类似于windows快捷方式,软链接保存另一个文件的路径）
5. 动态库vs静态库
6. 小端模式vs大端模式：（小：低有效字节存放在低地址。。。。），可以根据联合体判断，因为联合体总是从低字节开始存储
7. 字节序转换：网络协议规定大端模式，进行网络通信时必须转换。
8. 进程调度：FCFS，SF,HRN,时间片轮转，多级反馈   （抢占vs非抢占）
9. 物理内存（reg,cache,memory,disk）vs虚拟内存
10. 内核态vs用户态 (进入方式：系统调用，异常，中断)：处于安全性考虑
11. LRU算法：利用链表，当需要插入新数据时，存在则移动到链表头，没有则放到链表头，缓存满了就删除最后一个节点
12. 页表：虚拟内存到物理内存的映射（多级页表减少内存消耗）
13. 缺页中断：分配内存时只是建立虚拟地址空间，没有建立映射关系，进程访问时会触发缺页中断将也=页调入内存
14. 虚拟内存分布：text (代码段，二进制机器指令),data（已初始化的全局变量）,bss（未初始化的全局变量），堆（低到高），共享区，栈（高到低）
15. 进程，线程，协程：进程是程序的执行实体，线程是微进程（一个进程包含多个线程并发执行任务），
16. fork()：创建子进程，返回子进程PID.调用一次，返回两次
17. 孤儿进程：父进程退出后，子进程还在运行，被init进程收养。
18. 僵尸进程：子进程退出后父进程没有收到退出的信号，子进程的进程描述符依然保存在系统中，浪费系统资源。
19. 解决僵尸进程：1.及时wait调用，建立捕捉SIGCHLD信号的信号处理函数。2.kill 先用ps -aux | grep Z查看僵尸进程，然后kill
20. 守护进程：长期在后台运行的程序，用于控制终端，处理一些系统级别任务。
21. 进程间通信方式：管道，消息队列，信号，信号量，内存共享。
22. 进程状态：创建，就绪，执行，阻塞，中止。
23. 死锁发生的条件：互斥，请求保持，不可剥夺，环路等待
24. 自旋锁:只有一个锁，只能被一个线程持有，会造成忙等。自旋锁与锁互斥锁的区别，不会使线程状态发生改变减少了上下文切换。
25. DMA:进行数据传输时，将数据搬运工作交给DMA控制器，期间CPU可以做其他工作。
26. 零拷贝：传统的文件传输会经过4次拷贝（磁盘->内核，内核->用户，用户->socket,socket->网卡），但其实用户缓冲区没有存在的必要（因为不修改内容），减少上下文切换的成本。原因：用户没有权限操作磁盘，网卡，需要通过系统调用陷入到内核态，从而发生上下文切换。（传输大文件不能采用零拷贝技术，因为cache被占用，导致小文件无法利用cache,并且大文件的chache的命中率不高，应该采用异步IO+直接IO的方式。）
27. mmap：内核缓冲区的数据映射到用户空间，减少了一次数据拷贝。sendfile:减少了用户缓冲区。 后期：全程不通过CPU拷贝数据，而是通过DMA进行
28. epoll和select（多路IO复用）：select要等待数据的复制
29. 多路IO 复用（基于非阻塞）：吃饭有一排窗口都没做好，阿姨说做好了通知你，过了一会阿姨通知你，但是你得自己看是哪一个窗口做好了，然后等待阿姨打饭。
30. 阻塞IO：去食堂吃饭，但是没做好，一直在食堂等到饭做好并等待阿姨打饭，最后吃饭。
31. 非阻塞IO：去食堂吃饭，但是没做好，阿姨说做好通知你，你去干其他事，通知你之后你去吃饭得等待打饭的过程。
32. 异步IO：你让阿姨做好饭并打包号再通知你。
33. 水平触发与边缘触发：LT：只要缓冲区还有数据下一次就接着读   ET：只有缓冲区状态改变才能读（必须一次处理完）
34. 网络模型：物理层，数据链路层，网络层(IP)，传输层（TCP,UDP），会话层（DNS），表示层，应用层（文件传输，文件管理等）
35. 文件系统：文件（inode（磁盘里）+目录项（内存中）），文件存储方式（连续，非连续（链表（隐式，显式），索引（多级索引））），缓冲IO与非缓冲IO，直接IO（不会发生内核缓存与用户程序直接复制）与非直接IO，阻塞IO（等到数据准备和数据从内核 态到用户态的拷贝）非阻塞IO（周期轮询（轮询期间CPU不做事，所以引出IO多路复用）数据是否准备好，没有则返回，由则等待数据从内核态到用户态的拷贝。）以上都是同步调用，因为不用态之间的数据复制必须等待。

## 进阶

1. 



